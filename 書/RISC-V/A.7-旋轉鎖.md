## RISC-V 上的旋轉鎖實作 (以組合語言範例解說)

旋轉鎖 (spinlock) 是一種用來同步多個執行緒存取共享資源的方法之一。當一個執行緒需要存取底層的共享資源時，它會嘗試鎖定旋轉鎖；如果該鎖已被其他執行緒鎖定，則該執行緒會進入忙碌等待狀態，直到鎖被釋放為止。在 RISC-V 架構下，可以透過原子指令來實現旋轉鎖。

以下是一個簡單的旋轉鎖實作，使用 RISC-V 的進階加載 (AMO) 指令進行原子操作。在此範例中，我們使用名為 `lock` 的 32 位元旋轉鎖，如果 `lock` 的值為 0，則表示該鎖可以被取得，否則表示該鎖已經被取得。如果我們想取得該鎖，我們需要不斷地嘗試鎖定該鎖 (即不斷地嘗試原子比較和交換操作），直到成功鎖定為止。

以下是使用 RISC-V 組合語言實現的旋轉鎖範例：

```assembly
# 定義一個 32 位元的旋轉鎖，初始值為 0
.section .data
.align 4
lock: .word 0

.section .text
.align 2
# 鎖定旋轉鎖
spin_lock:
    # 進入無窮迴圈，直到成功鎖定
1:  li t0, 1        # 加載常數 1 到 $t0 中，用於後續操作
    amoswap.w.aq t1, t0, (lock)   # 原子比較和交換操作，如果鎖未被取得，則將 1 寫入 lock 中
    bnez t1, 1b      # 如果 amoswap 操作返回的值不為 0（即鎖已被取得），則跳回標籤 1，重新嘗試鎖定
    jr ra           # 操作完成，直接返回

# 釋放旋轉鎖
spin_unlock:
    li t0, 0        # 將常數 0 加載到 $t0 中，用於後續操作
    sw t0, (lock)   # 將 $t0 中的值寫入 lock 中，表示鎖已經被釋放
    jr ra           # 操作完成，直接返回
```

在上述範例中，`spin_lock` 子程序實現了鎖定旋轉鎖的功能，透過 `amoswap.w.aq` 指令可以實現原子比較和交換操作。如果該指令成功修改了 `lock` 的值（即鎖定該鎖），則會返回 0，`bnez` 指令會跳轉到 `1b` 標籤。否則，如果鎖已經被取得，則該指令會返回 1，`bnez` 指令會跳轉回標籤 1，重新開始鎖定。

相對地，`spin_unlock` 子程序實現了釋放旋轉鎖的功能，透過 `sw` 指令將 0 寫入 `lock` 中，表示鎖已經被釋放。

需要注意的是，在 RISC-V 架構下，對單個 32 位元變數的 AMO 操作是原子化的，因此我們不需要額外的同步原語來確保操作的原子性。此外，`amoswap.w.aq` 指令中的 `aq` 參數是為了確保原子性。當 `aq` 為 1 時，該指令會確保現有的所有存取都在之後的所有儲存之前完成。這可以確保在實現兩相同步 (two-phase handshake) 的情況下不會出現競態條件。

總體而言，透過 RISC-V 的原子指令，我們可以在處理器級別上實現高效的旋轉鎖，同步執行緒之間的共享資源存取。