## 1. 指標和陣列的使用的陷阱

指標和陣列在 C 語言中是非常重要的概念，然而如果使用不當也容易踩到一些陷阱。

1.1 空指標的使用

當宣告指標變數時，如果不初始化該變數即給予一個有效的地址，則指標將被初始化為一個空指標。在後續使用空指標時，如果不進行 NULL 檢查就直接取值或修改值，那麼程式會出現未定義的行為，甚至可能發生 segfault 崩潰。

以下程式碼展示了使用空指標時產生的錯誤：

```c
int *p;
int a = *p;
```

由於 p 是一個未初始化的指標，它指向的地址是不明的。因此，在第二行中嘗試讀取該指標的值會導致未定義的行為。

1.2 陣列範圍的超出

在使用陣列時，如果沒有注意到陣列的範圍，就有可能會造成記憶體越界而導致錯誤。

以下程式碼展示了超出陣列範圍時產生的錯誤：

```c
int arr[5] = {1, 2, 3, 4, 5};
int i;
for (i = 0; i <= 5; i++) {
    printf("%d ", arr[i]);
}
```

由於陣列 arr 的大小為 5，但是在 for 迴圈中，從 0 到 5 共執行了 6 次，最後一次訪問了 arr 之外的記憶體地址，造成未定義的行為。因此，應該在 for 迴圈中使用 `<` 運算符，以保證不超出陣列範圍。

1.3 指標和陣列的混淆

在某些情況下，指標和陣列可能被混淆。例如，陣列名本質上是一個指向陣列第一個元素的指標。而當我們使用陣列下標運算符（`[]`）時，實際上是在進行指標的算術運算。因此，將指標和陣列混淆使用可能會導致一些錯誤。

以下程式碼展示了指標和陣列混淆使用時產生的錯誤：

```c
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr;
printf("%d %d\n", p[0], arr[1]);
printf("%d %d\n", *p, *(arr + 2));
```

在第一行中，p[0] 和 arr[0] 是等價的，因為 p 指向了 arr 的第一個元素。同樣地，在第二行中，*p 和 *(arr + 2) 也是等價的，因為它們都指向了 arr 的第三個元素。

但是，當我們將指標 p 設置為指向某個元素的地址時，上述規則就不再適用了。例如，以下程式碼展示了指標和陣列混淆使用時的錯誤：

```c
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr + 2;
printf("%d %d\n", p[0], arr[2]);
printf("%d %d\n", *p, *(arr + 4));
```

在第一行中，p[0] 和 arr[2] 是等價的，因為 p 指向了 arr 的第三個元素。但是，在第二行中，*p 和 *(arr + 4) 不相等，因為 p 指向了 arr 的第三個元素，而不是第五個元素。因此，指標和陣列混淆使用時需要小心。


以下列出 C 語言裡常見的指標陷阱：

1. 未初始化的指標：當你宣告一個指標時，需要將它初始化為 NULL。未初始化的指標會指向一個未知的記憶體位址，這很可能會導致程式錯誤或崩潰。

```c
int* ptr;  // 未初始化的指標
*ptr = 10; // 會導致錯誤
```

2. 超出陣列範圍：當你使用指標操作陣列時，需要確保你不會超出陣列範圍。超出陣列範圍會導致不可預期的行為，有可能會破壞記憶體或造成程式崩潰。

```c
int arr[10];
int* ptr = &arr[0];

for (int i = 0; i < 15; i++) {
    printf("%d\n", *(ptr + i)); // 超出陣列範圍
}
```

3. 回傳區域變數指標：當你想要回傳一個指向區域變數的指標時，需要小心處理。區域變數在函式執行完畢時會被釋放，如果你回傳指向區域變數的指標，你的程式在未來可能會指向不正確的記憶體位址。

```c
int* get_pointer() {
    int x = 10;
    return &x; // 回傳區域變數指標
}

int main() {
    int* ptr = get_pointer();
    printf("%d\n", *ptr); // 可能會得到不正確的結果
}
```

4. 釋放記憶體後繼續使用指標：當你使用 `free()` 釋放記憶體後，該記憶體區域被歸還給系統，你不應該使用指向那個記憶體位址的指標。這樣做會導致不可預期的行為。

```c
int* ptr = (int*)malloc(sizeof(int));
free(ptr);
*ptr = 10; // 不應該這樣使用釋放後的指標
```

5. 當成陣列使用指標：指標和陣列雖然相似，但是它們不是同一種型別。當你使用指標來操作陣列時，需要小心確保你不是越界存取。

```c
int arr[10] = {1,2,3,4,5,6,7,8,9,10};
int* ptr = arr;

for (int i = 0; i < 10; i++) {
    printf("%d\n", ptr[i]); // 這是可以的
}
printf("%d\n", ptr[10]);    // 不應該這樣存取
```